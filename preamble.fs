/// this file was generated by the arz parser generator
/// probably don't edit it by hand
/// take care of each other

module Generated

open System.Text.RegularExpressions

type SourceReader (source:string) =
    member val position = 0 with get, set
    member val source = source

type ArzLiteral = ArzLiteral of string
let peek (sr:SourceReader) =
    if sr.position < sr.source.Length
    then sr.source.[sr.position]
    else (char -1)

let position (sr:SourceReader) =
    sr.position

let reset (sr:SourceReader) position' =
    sr.position <- position'

let advance (sr:SourceReader) =
    reset sr (sr.position+1)

let read sr =
    let c = peek sr
    advance sr
    c

let readString sr length =
    let mutable s = ""
    for _ in 0..length do
        s <- s + (string (read sr))
    s    

let expect sr c =
    let p = position sr
    if read sr = c
    then Some c
    else reset sr p; None

let expectMatch (pattern:Regex) sr =
    let p = position sr
    let c = read sr
    if c <> '\uffff' && pattern.IsMatch (string c)
    then Some c
    else reset sr p; None

let expectMatchString sr (pattern:Regex) minimum =
    let p = position sr
    let rec readString s =
        match expectMatch pattern sr with
        | Some c -> readString (s + (string c))
        | None -> s
    match readString "" with
    | s when s.Length > minimum -> Some s
    | _ -> reset sr p; None

let expectAny sr (s:string) =
    let p = position sr
    let cs = Set.ofArray (s.ToCharArray())
    let c = read sr
    if Set.contains c cs
    then Some (string c)
    else reset sr p; None

let expectString sr (s:string) =
    let p = position sr
    let s' = readString sr (s.Length-1)
    if s' = s
    then Some s'
    else reset sr p; None

let expectLiteral sr (s:string) =
    match expectString sr s with
    | Some s' -> Some (ArzLiteral s')
    | _ -> None

let parseList sr minimum parsef =
    let p = position sr
    let rec readList list =
        match parsef sr with
        | Some x -> readList (List.append list [x])
        | None -> list
    match readList [] with
    | list when List.length list >= minimum -> Some list
    | _ -> reset sr p; None

/// START GENERATED GRAMMAR ///

